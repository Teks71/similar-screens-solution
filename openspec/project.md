# Project Context

## Purpose
Монорепозиторий на Python для сервиса «similar-screens-solution». Содержит единый источник Pydantic-контрактов, простой FastAPI-бэкенд, Telegram-бот и выделенный сервис генерации эмбеддингов, которые совместно предоставляют API и интерфейс взаимодействия.

## Tech Stack
- Python 3.11+
- uv workspace для менеджмента зависимостей и разработки
- FastAPI + Pydantic v2 для бэкенда, контрактов и embedding-service
- PyTorch + timm для модели эмбеддингов (DINOv2)
- Qdrant как векторное хранилище для бэкенда
- PostgreSQL как хранилище данных для индекса
- aiogram 3 для Telegram-бота
- httpx для HTTP-вызовов из бота
- MinIO как источник изображений для embedding-service

## Project Conventions

### Code Style
- Строгая типизация, явные `response_model` в FastAPI.
- Контракты описываются только в `contracts/contracts`, логики там быть не должно.
- Для разных методов контракта допускается разбивать модели по нескольким подпапкам и файлам; не складывайте все Pydantic-модели в один модуль.
- Бизнес-логика бота и бэкенда опирается на модели из `contracts`.
- Импорты моделей через `from contracts.dto import ...`.

### Architecture Patterns
- uv-workspace с четырьмя проектами: `contracts` (модели), `backend-service` (API), `telegram-bot` (клиентское взаимодействие), `embedding-service` (генерация эмбеддингов из изображений в MinIO).
- Все изменения API или данных начинаются с обновления моделей в `contracts`, далее синхронизация потребителей.
- Бэкенд реализуется поверх FastAPI, бот — поверх aiogram, генератор эмбеддингов — отдельный FastAPI-сервис с зависимостью от GPU.

### Testing Strategy
- Минимальные проверки пока включают базовый health-check; при добавлении функциональности требуются тесты, отражающие ожидаемое поведение API и использования контрактов.

### Git Workflow
- Стандартный git-flow не зафиксирован; коммиты должны быть осмысленными и отражать сделанные изменения.

## Domain Context
- Сервис предоставляет базовые эндпоинты `/health` и `/embed` в embedding-service (возвращает вектор для объекта в MinIO с проверкой разрешённого бакета) и бот-команду `/start`, служащие каркасом для расширения функциональности сравнения экранов.
- Бэкенд использует PostgreSQL и Qdrant для хранения индекса и результатов поиска похожих объектов, опираясь на эмбеддинги, выдаваемые отдельным сервисом.
- Генерация эмбеддингов выполняется моделью DINOv2 (vit_base_patch14_dinov2) на CUDA-устройствах; Docker Compose резервирует GPU для контейнера embedding-service.

## Important Constraints
- Нельзя создавать новые пакеты вне uv-workspace и дублировать модели вне `contracts`.
- Добавление зависимостей требует обновления соответствующих `pyproject.toml` внутри проектов.
- Новые структуры данных или API нужно сначала вводить в `contracts`.
- Сервисы разворачиваются через Docker; поддерживайте `docker-compose.yml`, `Dockerfile` и `.env.example` в актуальном состоянии при любых
  изменениях окружения или конфигурации, включая порты и переменные embedding-service.
- embedding-service требует доступности CUDA-устройства, настроенных переменных для MinIO (`MINIO_*`, при необходимости `MINIO_ALLOWED_BUCKET`) и параметров модели (`EMBEDDING_MODEL_NAME`, `EMBEDDING_DEVICE`).

## Logging
- Backend: уровень логирования задаётся переменной `BACKEND_LOG_LEVEL` (по умолчанию INFO) через `logging.basicConfig` с форматом `%(asctime)s %(levelname)s %(name)s %(message)s`.
- Для структурированных данных включайте JSON прямо в текст сообщения (например, `logger.info(f"event {json.dumps(payload)}")`), чтобы поля попадали в stdout контейнера без зависимости от formatter-а.
- Держите прикладные логи на INFO/DEBUG для диагностики, WARN/ERROR — для ошибок; access-логи uvicorn остаются отдельным потоком.

## External Dependencies
- Telegram Bot API (требуется токен в переменной окружения `TELEGRAM_BOT_TOKEN`).
- Внешний сервер MinIO (необходимы URL/регион, ключ и секрет доступа в переменных окружения бэкенда и embedding-service).
- CUDA-совместимый GPU для контейнера embedding-service.
- Qdrant (URL/порт, API-ключ и коллекции настраиваются через переменные окружения бэкенда).
- PostgreSQL (URL/порт, база данных, пользователь и пароль передаются через переменные окружения бэкенда).
- Доступ к PyTorch/timm зеркалам для загрузки весов DINOv2 при сборке или первом запуске embedding-service.
